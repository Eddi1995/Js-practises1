<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <script>
        let phone1={
            brand:"Nokia",
            model:"Nokia light"
        }
        let phone2={
            brand:"Samsung",
            model:"samsung ultra edge",
        }

        let store1=function date(month,yr){
        console.log(`${this.brand} ${this.model} was relesed on ${month} ${yr}`);   //NOTE:Ayncchronus fuction allways point to global object

        }
        store1();

        //1) To Set this keyword manually to the object
        //    -call;
        //    -Apply;  (old method and modern aproach) 
        //    -bind;
        //  

           //call method
           store1.call(phone1,"Apr",2020);       //call is the method to automaticall call the object

           store1.call(phone2,"Jan",2022);       //phone2 is the object and passing the argument.
                                                 //NOTE:When call method is assigned then automaticall object will be assigned inside the main calling object

          //Apply method;(similar to call method since argument is passed as an array)

          let data1=["Nov",1995];
          let data2=["Dec",1996];

          store1.apply(phone1,data1);
          store1.apply(phone2,data2);

          //Modern approach;

          store1.call(phone1,...data1);
          store1.call(phone2,...data2);

          // Bind (We can bind Achronus functiion object then new function is created and this can be called again and again)

          let bindObject=store1.bind(phone1);

          bindObject("JUN",1889);

          //2) Closures;   (For Explanation check the vedio and book explanation)
          //Any inner function which have a access to variable environment of the execution context in which the function 
          //was created even after the execution context leaves from the call stack.
        
//         Explantion: A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). 
//         In other words, a closure gives you access to an outer function's scope from an inner function.

            function count(){
                counter=0;
                return function (){
                    counter++;
                    console.log(counter);
                }
            }
            let z= count();
            console.log(z);

            z();

                    

         //3)IIFE (Immediately invoked function expression)
         //  This function is used to call the function only one time and it dies.

         let welcome=function greet(){
            console.log("WELCOME MAGA");
         }
          welcome();
          welcome();        //NOTE: This is the normal Asynchronus function which we can call again and again.


          (function welcome(input){
            console.log(input);
          }) ("welcome to paddack");      

          ("welcome home");

          //Function curring

          function area(l){
            return function(b){     
                return l*b;          //NOTE: L is asesed inside the function only bcs of closure
                                     //NOTE: If the second value need some time inside the function before that only main function executed and waits for the second value 
                                     //        are called function curring; 
            }
          }
         console.log(area(4)(3)) ;

         

    </script>
    
</body>
</html>
